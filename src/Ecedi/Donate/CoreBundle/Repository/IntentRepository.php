<?php
/**
 * @author Sylvain Gogel <sgogel@ecedi.fr>
 * @copyright Agence Ecedi (c) 2015
 * @license http://opensource.org/licenses/MIT MIT
 */
namespace Ecedi\Donate\CoreBundle\Repository;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\QueryBuilder;
use Ecedi\Donate\CoreBundle\Entity\Intent;

/**
 * IntentRepository.
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 *
 * @since 2.4.2 remove private method getDatetimeFromDate()
 */
class IntentRepository extends EntityRepository
{
    // Ajout des fonctions nous permettant d'appliquer les filtres à notre query
    use FilterTrait;

    /**
     * Fonction retournant les dernières Intentions de dons (nb = $limit).
     *
     * @param int $limit
     */
    public function getLastIntentsByLimit($limit)
    {
        // préparation de la requête
        $qb = $this->createQueryBuilder('i');
        $qb->add('orderBy', 'i.createdAt DESC')
           ->setMaxResults($limit);

        return $qb->getQuery()->getResult();
    }
    /**
     * Fonction qui retourne les intents filtrées.
     *
     * @param array $parameters
     */
    public function getQBIntentsListBy($parameters)
    {
        $qb = $this->createQueryBuilder('i');
        $qb->add('orderBy', 'i.createdAt DESC');
        $qb->join('i.customer', 'c');

        if (!empty($parameters)) {
            $this->applyFilters($qb, $parameters);
        }

        return $qb;
    }

    /**
     * Fonction qui retourne les intents d'un customer.
     *
     * @param array $parameters
     * @param int   $limit
     * @param array $exclude    -- id(s) d'intent(s) à exclure
     */
    public function getIntentsListByCustomer($parameters, $limit = 20, $exclude = false)
    {
        $qb = $this->createQueryBuilder('i');
        $qb->where('i.customer = :customerId')
           ->setParameter('customerId', $parameters['customerId'])
           ->setMaxResults($limit)
           ->orderBy('i.createdAt', 'DESC');

        if ($exclude) {
            $exclude = is_array($exclude) ? $exclude : (array) $exclude;
            $qb->andWhere('i.id NOT IN (:exlude)')
              ->setParameter('exlude', $exclude);
        }

        return $qb->getQuery();
    }

    /**
     *  Fonction permettant l'application des filtres/params a notre objet query.
     *
     * @param object $qb         -- Doctrine\ORM\QueryBuilder
     * @param array  $parameters -- filtres/paramètres
     *
     * @since  2.4.2 date values are already DateTime, no need for method getDatetimeFromDate()
     */
    private function applyFilters(QueryBuilder $qb, $parameters)
    {
        foreach ($parameters as $field => $value) {
            switch ($field) {
                // Filtre sur le type de don  (spot, recurring)
                case 'type':
                    $this->inFilter($qb, 'i', $field, $value);
                    break;
                // Filtre sur les statuts (new, pending ...)
                case 'status':
                    $this->inFilter($qb, 'i', $field, $value);
                    break;
                // Filtre sur l'email donateur
                case 'email':
                    if (!empty($value)) {
                        $this->matchFilter($qb, 'c', $field, 'LIKE', $value);
                    }
                    break;
                // Filtre sur le montant du don
                case 'minAmount':
                    $field = 'amount';
                    if (!empty($value)) {
                        $value = $this->getAmountInCents($value);
                        if (!empty($parameters['max_amount'])) {
                            $value2 = $this->getAmountInCents($parameters['max_amount']);

                            $this->rangeFilter($qb, 'i', $field, 'BETWEEN', $value, $value2);
                        } else {
                            $this->rangeFilter($qb, 'i', $field, '>=', $value);
                        }
                    }
                    break;

                case 'maxAmount':
                    $field = 'amount';
                    if (!empty($value)) {
                        $value = $this->getAmountInCents($value);
                        if (empty($parameters['min_amount'])) {
                            $this->rangeFilter($qb, 'i', $field, '<=', $value);
                        }
                    }
                    break;
                // Filtre sur la date du don
                case 'minCreatedAt':
                    $field = 'createdAt';
                    if (!empty($value)) {
                        //$value = $this->getDatetimeFromDate($value);
                        if (!empty($parameters['maxCreatedAt'])) {
                            $value2 = $this->getDatetimeFromDate($parameters['maxCreatedAt']);
                        } else {
                            $value2 = new \DateTime('NOW');
                        }
                        $this->rangeFilter($qb, 'i', $field, 'BETWEEN', $value, $value2);
                    }
                    break;

                case 'maxCreatedAt':
                    $field = 'createdAt';
                    if (!empty($value)) {
                        if (empty($parameters['minCreatedAt'])) {
                            //$value = $this->getDatetimeFromDate($value);
                            $this->rangeFilter($qb, 'i', $field, '<=', $value);
                        }
                    }
                    break;
                // Token fourni lors de la soumission du formulaire
                case '_token':
                    break;
            }
        }
    }

    /**
     * Fonction retournant un montant en cents.
     *
     * @param numeric $amount
     */
    private function getAmountInCents($amount)
    {
        if (strpos(',', $amount) !== false || strpos('.', $amount) !== false) {
            $amount = str_replace(',', '.', $amount);
            $amountInCents = number_format($amount, 2, '', '');
        } else {
            $amountInCents = $amount * 100;
        }

        return $amountInCents;
    }

    /**
     * Fonction qui retourne les plus haut dons ponctuels payés.
     *
     * @param int $limit
     */
    public function getHighestSpotDonatorIntent($limit = 5)
    {
        $qb = $this->createQueryBuilder('i');
        $qb->select('c.id AS customerId, c.lastName, c.firstName, SUM(i.amount) AS totalAmount')
           ->join('i.customer', 'c')
           ->where('i.type = :intentType')
           ->andWhere('i.status = :intentStatus')
           ->groupBy('customerId')
           ->orderBy('totalAmount', 'DESC')
           ->setMaxResults($limit);

        $qb->setParameters([
            'intentType' => Intent::TYPE_SPOT,
            'intentStatus' => Intent::STATUS_DONE,
        ]);

        return $qb->getQuery()->getResult();
    }

    /**
     * Fonction qui retourne les plus hauts dons récurrent payés.
     *
     * @param int $limit
     */
    public function getHighestRecurringDonatorIntent($limit = 5)
    {
        $qb = $this->createQueryBuilder('i');
        $qb->select('c.id AS customerId, c.lastName, c.firstName, SUM(i.amount) AS totalAmount')
           ->join('i.customer', 'c')
           ->where('i.type = :intentType')
           ->andWhere('i.status = :intentStatus')
           ->groupBy('customerId')
           ->orderBy('totalAmount', 'DESC')
           ->setMaxResults($limit);

        $qb->setParameters([
            'intentType' => Intent::TYPE_RECURING,
            'intentStatus' => Intent::STATUS_DONE,
        ]);

        return $qb->getQuery()->getResult();
    }
    /**
     * Fonction retournant le nombre d'intent selon leur statut.
     *
     * @param Intent Status
     *
     * @return int -- le nombre d'intent
     */
    public function getCountByStatus($status = Intent::STATUS_DONE)
    {
        $qb = $this->createQueryBuilder('i');
        $qb->select('count(i.id)')
           ->where('i.status = :intentStatus');

        $qb->setParameters(['intentStatus' => $status]);

        return $qb->getQuery()->getSingleScalarResult();
    }

    /**
     * Fonction retournant le nombre total d'entités.
     *
     * @return int -- le nombre total d'intent
     */
    public function countAll()
    {
        return $this->createQueryBuilder('i')
            ->select('COUNT(i)')
            ->getQuery()
            ->getSingleScalarResult();
    }

    /**
     * Fonction pour le webservice retournant les intents.
     *
     * @param array() $params
     *
     * @return ArrayCollection d' Intent
     */
    public function findByRestParams($params)
    {
        $defaultLimit = 10;
        $defaultOffset = 0;

        // Application des paramètres par défaut si besoin
        $limit = isset($params['limit']) ? $params['limit'] : $defaultLimit;
        $limit = $limit >= 100 ? 100 : $limit; // la limit max est de 100 obligatoirement
        $offset = isset($params['offset']) ? $params['offset'] : $defaultOffset;

        $qb = $this->createQueryBuilder('i');
        if (!empty($params['since'])) {
            $createdAt = date('Y-m-d H:i:s', $params['since']);
            $qb->where('i.createdAt >= :createdAt')
               ->setParameter(':createdAt', $createdAt);
        }

        $qb->setMaxResults($limit)
           ->setFirstResult($offset)
           ->orderBy('i.createdAt', 'DESC');

        return $qb->getQuery()->getResult();
    }
}
